{"pageProps":{"post":{"attributes":{"description":"Learn how JavaScript moves function declarations to the top of their scope."},"html":"<h1>Hoisting</h1>\n<p>Hoisting is a JavaScript behavior where function declarations are moved to the top of their scope during compilation. This allows you to use functions before they&#39;re defined in your code.</p>\n<h2>Normal JavaScript Execution Order</h2>\n<p>Normally, JavaScript executes code from top to bottom:</p>\n<pre><code class=\"hljs language-javascript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-comment\">// ✅ This works - variable defined before use</span>\n<span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a) <span class=\"hljs-comment\">// 1</span>\n</code></pre><pre><code class=\"hljs language-javascript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-comment\">// ❌ This doesn&#x27;t work - variable used before definition</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(b) <span class=\"hljs-comment\">// ReferenceError: Cannot access &#x27;b&#x27; before initialization</span>\n<span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-number\">2</span>\n</code></pre><h3>Function Hoisting in Action</h3>\n<p>However, functions work differently. You can call a function <strong>before</strong> it&#39;s defined:</p>\n<pre><code class=\"hljs language-javascript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-comment\">// ✅ This works! Function is called before it&#x27;s defined</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)) <span class=\"hljs-comment\">// 3</span>\n\n<span class=\"hljs-comment\">// Function defined after it&#x27;s called</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">a, b</span>) {\n  <span class=\"hljs-keyword\">return</span> a + b\n}\n</code></pre><h2>How Hoisting Works</h2>\n<p>Before JavaScript runs your code, it does a preliminary scan and <strong>moves all function declarations to the top</strong> of their scope.</p>\n<p>It&#39;s as if JavaScript rewrites your code like this:</p>\n<pre><code class=\"hljs language-javascript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-comment\">// What you write:</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>))\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">a, b</span>) {\n  <span class=\"hljs-keyword\">return</span> a + b\n}\n</code></pre><pre><code class=\"hljs language-javascript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-comment\">// How JavaScript sees it (conceptually):</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">a, b</span>) {\n  <span class=\"hljs-keyword\">return</span> a + b\n}\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>))\n</code></pre><p>Functions are either hoisted to the top of the global scope or the top of their containing function scope, depending on where they are defined.</p>\n<h3>Arrow Functions Are <strong>NOT</strong> Hoisted</h3>\n<p>Arrow functions behave like variables and are <strong>not hoisted</strong>:</p>\n<pre><code class=\"hljs language-javascript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-comment\">// ✅ This works with normal functions</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)) <span class=\"hljs-comment\">// 3</span>\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">a, b</span>) {\n  <span class=\"hljs-keyword\">return</span> a + b\n}\n</code></pre><pre><code class=\"hljs language-javascript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-comment\">// ❌ This doesn&#x27;t work with arrow functions</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">sumArrow</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)) <span class=\"hljs-comment\">// ReferenceError: Cannot access &#x27;sumArrow&#x27; before initialization</span>\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">sumArrow</span> = (<span class=\"hljs-params\">a, b</span>) =&gt; {\n  <span class=\"hljs-keyword\">return</span> a + b\n}\n</code></pre><h2>Why Hoisting Is Useful</h2>\n<p>Hoisting allows you to organize your code more flexibly. You can place your main program logic at the top and helper functions below, improving readability:</p>\n<pre><code class=\"hljs language-javascript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-comment\">// Main program logic (easy to read)</span>\n<span class=\"hljs-title function_\">processUserData</span>()\n<span class=\"hljs-title function_\">displayResults</span>()\n<span class=\"hljs-title function_\">cleanup</span>()\n\n<span class=\"hljs-comment\">// Helper functions (implementation details)</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">processUserData</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Processing...&quot;</span>)\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">displayResults</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Displaying results...&quot;</span>)\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">cleanup</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Cleaning up...&quot;</span>)\n}\n</code></pre>","markdown":"\n# Hoisting\n\nHoisting is a JavaScript behavior where function declarations are moved to the top of their scope during compilation. This allows you to use functions before they're defined in your code.\n\n## Normal JavaScript Execution Order\n\nNormally, JavaScript executes code from top to bottom:\n\n```javascript\n// ✅ This works - variable defined before use\nlet a = 1\nconsole.log(a) // 1\n```\n\n```javascript\n// ❌ This doesn't work - variable used before definition\nconsole.log(b) // ReferenceError: Cannot access 'b' before initialization\nlet b = 2\n```\n\n### Function Hoisting in Action\n\nHowever, functions work differently. You can call a function **before** it's defined:\n\n```javascript\n// ✅ This works! Function is called before it's defined\nconsole.log(sum(1, 2)) // 3\n\n// Function defined after it's called\nfunction sum(a, b) {\n  return a + b\n}\n```\n\n## How Hoisting Works\n\nBefore JavaScript runs your code, it does a preliminary scan and **moves all function declarations to the top** of their scope.\n\nIt's as if JavaScript rewrites your code like this:\n\n```javascript\n// What you write:\nconsole.log(sum(1, 2))\n\nfunction sum(a, b) {\n  return a + b\n}\n```\n\n```javascript\n// How JavaScript sees it (conceptually):\nfunction sum(a, b) {\n  return a + b\n}\n\nconsole.log(sum(1, 2))\n```\n\nFunctions are either hoisted to the top of the global scope or the top of their containing function scope, depending on where they are defined.\n\n### Arrow Functions Are **NOT** Hoisted\n\nArrow functions behave like variables and are **not hoisted**:\n\n```javascript\n// ✅ This works with normal functions\nconsole.log(sum(1, 2)) // 3\n\nfunction sum(a, b) {\n  return a + b\n}\n```\n\n```javascript\n// ❌ This doesn't work with arrow functions\nconsole.log(sumArrow(1, 2)) // ReferenceError: Cannot access 'sumArrow' before initialization\n\nconst sumArrow = (a, b) => {\n  return a + b\n}\n```\n\n## Why Hoisting Is Useful\n\nHoisting allows you to organize your code more flexibly. You can place your main program logic at the top and helper functions below, improving readability:\n\n```javascript\n// Main program logic (easy to read)\nprocessUserData()\ndisplayResults()\ncleanup()\n\n// Helper functions (implementation details)\nfunction processUserData() {\n  console.log(\"Processing...\")\n}\n\nfunction displayResults() {\n  console.log(\"Displaying results...\")\n}\n\nfunction cleanup() {\n  console.log(\"Cleaning up...\")\n}\n```\n","slug":"hoisting","title":"Hoisting","section":"Scope","icon":"eye","filePath":"/home/runner/work/fem-getting-started-with-javascript/fem-getting-started-with-javascript/lessons/06-scope/B-hoisting.md","nextSlug":"/fem-getting-started-with-javascript/lessons/scope/closures","prevSlug":"/fem-getting-started-with-javascript/lessons/scope/understanding-scope"}},"__N_SSG":true}