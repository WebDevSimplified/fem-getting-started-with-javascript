{"pageProps":{"post":{"attributes":{"description":"Learn how inner functions can access variables from outer scopes, even after the outer function has finished executing."},"html":"<h1>Closures</h1>\n<p>Closures are one of JavaScript&#39;s most powerful features, but they often intimidate developers. If you&#39;ve ever heard the word &quot;closure&quot; and immediately feared it because everyone said it&#39;s really difficult, don&#39;t worry! We&#39;ve essentially already learned everything about closures when we studied scoping.</p>\n<p>⚠️ <strong>WARNING:</strong> This is a tricky topic, so take your time to understand it fully!</p>\n<h2>What is a Closure?</h2>\n<p>A closure happens when an inner function has access to variables from an outer scope. We&#39;ve actually been using closures without realizing it!</p>\n<h3>Simple Closure Example</h3>\n<pre><code class=\"hljs language-javascript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a) <span class=\"hljs-comment\">// Accessing variable from outer scope</span>\n}\n\n<span class=\"hljs-title function_\">print</span>() <span class=\"hljs-comment\">// Prints: 1</span>\n</code></pre><p>This is technically a closure! The <code>print</code> function has access to the variable <code>a</code> from the outer scope.</p>\n<h3>Closures with Dynamic Values</h3>\n<p>What makes closures confusing is they access the <strong>current value</strong> of variables, not the value they had when the closure was created:</p>\n<pre><code class=\"hljs language-javascript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a)\n}\n\na = <span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">// Change the value before calling the function</span>\n<span class=\"hljs-title function_\">print</span>() <span class=\"hljs-comment\">// Prints: 2 (not 1!)</span>\n</code></pre><p>The function reads whatever the most recent value of <code>a</code> is when we actually call the function.</p>\n<h2>Functions Inside Functions</h2>\n<p>The textbook example of closures involves functions inside other functions:</p>\n<pre><code class=\"hljs language-javascript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">outer</span>(<span class=\"hljs-params\">a</span>) {\n  <span class=\"hljs-comment\">// This function returns another function</span>\n  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">inner</span>(<span class=\"hljs-params\">b</span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a) <span class=\"hljs-comment\">// From outer scope (outer function)</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(b) <span class=\"hljs-comment\">// From current scope (inner function)</span>\n  }\n\n  <span class=\"hljs-keyword\">return</span> inner <span class=\"hljs-comment\">// Return the inner function</span>\n}\n\n<span class=\"hljs-comment\">// Create a new function by calling outer</span>\n<span class=\"hljs-keyword\">const</span> newFunc = <span class=\"hljs-title function_\">outer</span>(<span class=\"hljs-number\">1</span>)\n\n<span class=\"hljs-comment\">// Call the returned function</span>\n<span class=\"hljs-title function_\">newFunc</span>(<span class=\"hljs-number\">2</span>)\n<span class=\"hljs-comment\">// Output:</span>\n<span class=\"hljs-comment\">// 1</span>\n<span class=\"hljs-comment\">// 2</span>\n</code></pre><h3>How This Works Step by Step</h3>\n<ol>\n<li>We call <code>outer(1)</code>, which creates a function that &quot;remembers&quot; <code>a = 1</code></li>\n<li><code>outer</code> returns the <code>inner</code> function</li>\n<li>We store this returned function in variable <code>newFunc</code></li>\n<li>When we call <code>newFunc(2)</code>, it runs <code>inner(2)</code>, which:<ul>\n<li>Logs <code>a</code> (which is <code>1</code> from the outer scope)</li>\n<li>Logs <code>b</code> (which is <code>2</code> from the current call)</li>\n</ul>\n</li>\n</ol>\n<h2>Accessing Multiple Scope Levels</h2>\n<p>Closures can access variables from multiple outer scopes:</p>\n<pre><code class=\"hljs language-javascript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-keyword\">const</span> c = <span class=\"hljs-number\">3</span> <span class=\"hljs-comment\">// Global scope</span>\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">outer</span>(<span class=\"hljs-params\">a</span>) {\n  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">inner</span>(<span class=\"hljs-params\">b</span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a) <span class=\"hljs-comment\">// From outer function scope</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(b) <span class=\"hljs-comment\">// From inner function scope</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(c) <span class=\"hljs-comment\">// From global scope</span>\n  }\n\n  <span class=\"hljs-keyword\">return</span> inner\n}\n\n<span class=\"hljs-keyword\">const</span> newFunc = <span class=\"hljs-title function_\">outer</span>(<span class=\"hljs-number\">1</span>)\n<span class=\"hljs-title function_\">newFunc</span>(<span class=\"hljs-number\">2</span>)\n<span class=\"hljs-comment\">// Output:</span>\n<span class=\"hljs-comment\">// 1</span>\n<span class=\"hljs-comment\">// 2</span>\n<span class=\"hljs-comment\">// 3</span>\n</code></pre><p>The inner function has access to:</p>\n<ul>\n<li>Its own parameters (<code>b</code>)</li>\n<li>The outer function&#39;s parameters (<code>a</code>)</li>\n<li>Global variables (<code>c</code>)</li>\n</ul>\n<h2>The Key Rule: One-Way Access</h2>\n<p>Remember the fundamental rule from scoping:</p>\n<ul>\n<li>✅ <strong>Inner scopes can read outer scopes</strong></li>\n<li>❌ <strong>Outer scopes cannot read inner scopes</strong></li>\n</ul>\n<p>This is why closures work - the inner function can always access variables from outside.</p>\n<h2>Why Closures Matter</h2>\n<p>Closures are extremely useful for:</p>\n<ol>\n<li><strong>Function Factories</strong> - Creating customized functions</li>\n<li><strong>Callbacks</strong> - Maintaining access to variables in asynchronous code</li>\n</ol>\n<h3>Interview Questions</h3>\n<p>Closures are a favorite topic in JavaScript interviews. You might see code like this:</p>\n<pre><code class=\"hljs language-javascript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">outer</span>(<span class=\"hljs-params\">x</span>) {\n  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">inner</span>(<span class=\"hljs-params\">y</span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x + y)\n  }\n  <span class=\"hljs-keyword\">return</span> inner\n}\n\n<span class=\"hljs-keyword\">const</span> addFive = <span class=\"hljs-title function_\">outer</span>(<span class=\"hljs-number\">5</span>)\n<span class=\"hljs-title function_\">addFive</span>(<span class=\"hljs-number\">3</span>) <span class=\"hljs-comment\">// What does this print?</span>\n</code></pre><p><strong>Answer:</strong> It prints <code>8</code> because:</p>\n<ul>\n<li><code>outer(5)</code> creates a closure where <code>x = 5</code></li>\n<li>Returns the <code>inner</code> function that remembers <code>x = 5</code></li>\n<li><code>addFive(3)</code> calls <code>inner(3)</code>, which logs <code>5 + 3 = 8</code></li>\n</ul>\n<h2>Practice Exercise</h2>\n<p>Create a function called <code>createGreeter</code> that:</p>\n<ol>\n<li>Takes a <code>greeting</code> parameter (like &quot;Hello&quot; or &quot;Hi&quot;)</li>\n<li>Returns a function that takes a <code>name</code> parameter</li>\n<li>The returned function should log the greeting + name</li>\n</ol>\n<details>\n<summary>Solution</summary>\n\n<pre><code class=\"hljs language-javascript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createGreeter</span>(<span class=\"hljs-params\">greeting</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">name</span>) =&gt;</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(greeting + <span class=\"hljs-string\">&quot; &quot;</span> + name)\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> sayHello = <span class=\"hljs-title function_\">createGreeter</span>(<span class=\"hljs-string\">&quot;Hello&quot;</span>)\n<span class=\"hljs-keyword\">const</span> sayHi = <span class=\"hljs-title function_\">createGreeter</span>(<span class=\"hljs-string\">&quot;Hi&quot;</span>)\n\n<span class=\"hljs-title function_\">sayHello</span>(<span class=\"hljs-string\">&quot;Kyle&quot;</span>) <span class=\"hljs-comment\">// &quot;Hello Kyle&quot;</span>\n<span class=\"hljs-title function_\">sayHi</span>(<span class=\"hljs-string\">&quot;Sarah&quot;</span>) <span class=\"hljs-comment\">// &quot;Hi Sarah&quot;</span>\n</code></pre></details>\n","markdown":"\n# Closures\n\nClosures are one of JavaScript's most powerful features, but they often intimidate developers. If you've ever heard the word \"closure\" and immediately feared it because everyone said it's really difficult, don't worry! We've essentially already learned everything about closures when we studied scoping.\n\n⚠️ **WARNING:** This is a tricky topic, so take your time to understand it fully!\n\n## What is a Closure?\n\nA closure happens when an inner function has access to variables from an outer scope. We've actually been using closures without realizing it!\n\n### Simple Closure Example\n\n```javascript\nconst a = 1\n\nfunction print() {\n  console.log(a) // Accessing variable from outer scope\n}\n\nprint() // Prints: 1\n```\n\nThis is technically a closure! The `print` function has access to the variable `a` from the outer scope.\n\n### Closures with Dynamic Values\n\nWhat makes closures confusing is they access the **current value** of variables, not the value they had when the closure was created:\n\n```javascript\nlet a = 1\n\nfunction print() {\n  console.log(a)\n}\n\na = 2 // Change the value before calling the function\nprint() // Prints: 2 (not 1!)\n```\n\nThe function reads whatever the most recent value of `a` is when we actually call the function.\n\n## Functions Inside Functions\n\nThe textbook example of closures involves functions inside other functions:\n\n```javascript\nfunction outer(a) {\n  // This function returns another function\n  function inner(b) {\n    console.log(a) // From outer scope (outer function)\n    console.log(b) // From current scope (inner function)\n  }\n\n  return inner // Return the inner function\n}\n\n// Create a new function by calling outer\nconst newFunc = outer(1)\n\n// Call the returned function\nnewFunc(2)\n// Output:\n// 1\n// 2\n```\n\n### How This Works Step by Step\n\n1. We call `outer(1)`, which creates a function that \"remembers\" `a = 1`\n2. `outer` returns the `inner` function\n3. We store this returned function in variable `newFunc`\n4. When we call `newFunc(2)`, it runs `inner(2)`, which:\n   - Logs `a` (which is `1` from the outer scope)\n   - Logs `b` (which is `2` from the current call)\n\n## Accessing Multiple Scope Levels\n\nClosures can access variables from multiple outer scopes:\n\n```javascript\nconst c = 3 // Global scope\n\nfunction outer(a) {\n  function inner(b) {\n    console.log(a) // From outer function scope\n    console.log(b) // From inner function scope\n    console.log(c) // From global scope\n  }\n\n  return inner\n}\n\nconst newFunc = outer(1)\nnewFunc(2)\n// Output:\n// 1\n// 2\n// 3\n```\n\nThe inner function has access to:\n\n- Its own parameters (`b`)\n- The outer function's parameters (`a`)\n- Global variables (`c`)\n\n## The Key Rule: One-Way Access\n\nRemember the fundamental rule from scoping:\n\n- ✅ **Inner scopes can read outer scopes**\n- ❌ **Outer scopes cannot read inner scopes**\n\nThis is why closures work - the inner function can always access variables from outside.\n\n## Why Closures Matter\n\nClosures are extremely useful for:\n\n1. **Function Factories** - Creating customized functions\n2. **Callbacks** - Maintaining access to variables in asynchronous code\n\n### Interview Questions\n\nClosures are a favorite topic in JavaScript interviews. You might see code like this:\n\n```javascript\nfunction outer(x) {\n  function inner(y) {\n    console.log(x + y)\n  }\n  return inner\n}\n\nconst addFive = outer(5)\naddFive(3) // What does this print?\n```\n\n**Answer:** It prints `8` because:\n\n- `outer(5)` creates a closure where `x = 5`\n- Returns the `inner` function that remembers `x = 5`\n- `addFive(3)` calls `inner(3)`, which logs `5 + 3 = 8`\n\n## Practice Exercise\n\nCreate a function called `createGreeter` that:\n\n1. Takes a `greeting` parameter (like \"Hello\" or \"Hi\")\n2. Returns a function that takes a `name` parameter\n3. The returned function should log the greeting + name\n\n<details>\n<summary>Solution</summary>\n\n```javascript\nfunction createGreeter(greeting) {\n  return (name) => {\n    console.log(greeting + \" \" + name)\n  }\n}\n\nconst sayHello = createGreeter(\"Hello\")\nconst sayHi = createGreeter(\"Hi\")\n\nsayHello(\"Kyle\") // \"Hello Kyle\"\nsayHi(\"Sarah\") // \"Hi Sarah\"\n```\n\n</details>\n","slug":"closures","title":"Closures","section":"Scope","icon":"eye","filePath":"/home/runner/work/fem-getting-started-with-javascript/fem-getting-started-with-javascript/lessons/06-scope/C-closures.md","nextSlug":"/fem-getting-started-with-javascript/lessons/advanced-variables/creating-variables-with-var","prevSlug":"/fem-getting-started-with-javascript/lessons/scope/hoisting"}},"__N_SSG":true}